<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java中的反射机制 | zhangzhang-blog</title><meta name="keywords" content="Java"><meta name="author" content="zhangzhang"><meta name="copyright" content="zhangzhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java中的反射机制"><meta name="application-name" content="java中的反射机制"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java中的反射机制"><meta property="og:url" content="http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/index.html"><meta property="og:site_name" content="zhangzhang-blog"><meta property="og:description" content="一、反射概述1. 什么是反射？反射（Reflection），Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信息。 反射机制一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题。 2. 反射机制原理反射机制允许 Java 程序在"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=52fea558-31d3-279e-541b-87c730ca6dde"><meta property="article:author" content="zhangzhang"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=52fea558-31d3-279e-541b-87c730ca6dde"><meta name="description" content="一、反射概述1. 什么是反射？反射（Reflection），Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信息。 反射机制一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题。 2. 反射机制原理反射机制允许 Java 程序在"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: zhangzhang","link":"链接: ","source":"来源: zhangzhang-blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'zhangzhang-blog',
  title: 'java中的反射机制',
  postAI: '',
  pageFillDescription: '一、反射概述, 1. 什么是反射？, 2. 原理, 3. 反射优点和缺点, 4. 类加载概述, 5. 类加载各阶段完成的功能, 5.1 加载阶段, 5.2 连接阶段——验证, 5.3 连接阶段——准备, 5.4 连接阶段——解析, 5.5 初始化阶段, 二、Class 类, 具体创建时机：JVM 加载类时（类加载阶段）, 1. 动态加载, 2. 小结, 三、访问字段, 1. 获取字段值, 2. 设置字段值, 3. 小结, 四、调用方法, 1. 调用方法, 2. 调用静态方法, 3. 调用非 public方法, 4. 多态, 5. 小结, 五、调用构造方法, 六、获取继承方法, 1. 获取父类的Class, 2. 获取interface, 3. 继承关系, 4. 小结, 七、动态代理一反射概述什么是反射反射中的反射机制是指程序在运行期间可以获取到一个对象的全部信息反射机制一般用来解决程序运行期间对某个实例对象一无所知的情况下如何调用该对象内部的方法问题反射机制原理反射机制允许程序在运行时调用取得任何类的内部信息比如成员变量构造器成员方法等并能操作类的实例对象的属性以及方法在程序中加载完一个类后在堆内存中就会产生该类的一个对象一个类在堆内存中最多只会有一个对象这个对象包含了该类的完整结构信息我们通过这个对象便可以得到该类的完整结构信息这个对象就像是一面镜子我们透过这面镜子可以清楚地看到类的结构信息因此我们形象的将获取对象的过程称为反射反射机制原理示意图反射优点和缺点优点可以动态地创建和使用对象反射机制是框架的底层核心其使用灵活没有反射机制底层框架就失去支撑缺点使用反射基本是解释执行对程序执行速度有影响类加载概述在深入讲解反射前先来介绍一下中类的加载与反射机制反射机制是实现动态语言的关键也就是通过反射实现类的动态加载静态加载编译时就加载相关的类如果程序中不存在该类则编译报错依赖性太强动态加载运行时加载相关的类即使程序中不存在该类但如果运行时未使用到该类也不会编译错误依赖性较弱举个例子通过反射创建一个类对象不提供代码只是文字说明上面代码中根据的值选择创建对象但是在代码编译时编译器会先检查程序中是否存在类如果没有则会编译报错编译器不会检查是否存在类因为类是使用反射的方式创建的所以即使程序中不存在类也不会编译报错而是等到程序运行时我们真正选择了后才会去检查类是否存在类加载的时机静态加载当新创建一个对象时该类会被加载当调用类中的静态成员时该类会被加载当子类被加载时其超类也会被加载动态加载通过反射的方式在程序运行时使用到哪个类该类才会被加载类加载的过程图类加载各阶段完成的功能加载阶段将类的文件读入内存并为之创建一个对象此过程由类加载器完成连接阶段又分为验证准备解析三个小阶段此阶段会将类的二进制数据合并到中初始化阶段负责对类的静态成员进行初始化如下图所示加载阶段在该阶段的主要目的是将字节码从不同的数据源可能是文件包甚至网络文件转换为二进制字节流加载到内存中并生成一个代表该类的对象连接阶段验证连接阶段准备会在该阶段对静态变量分配内存并进行默认初始化不同数据类型会有其默认初始值如等这些变量的内存空间会在方法区中分配举例如下属性成员变量字段类加载的连接阶段准备属性是如何加载的代码说明是实例属性不是静态变量因此在准备阶段是不会分配内存是静态变量在该阶段会为其分配内存默认初始化的值为而不是被修饰是常量它和静态变量不一样其一旦赋值后值就不变因此其默认初始化连接阶段解析将常量池内的符号引用替换为直接引用的过程初始化阶段在初始化阶段才会真正执行类中定义的程序代码此阶段是执行方法的过程方法是由编译器按语句在源文件中出现的顺序依次自动收集类中的所有静态变量的赋值操作和静态代码块中的语句并进行合并的过程会保证一个类的方法在多线程环境中被正确地加锁同步如果多个线程同时去初始化一个类那么只会有一个线程去执行这个类的方法其他线程都要阻塞等待直到活动线程执行方法完毕举例如下直接使用类的静态属性也会导致类的加载静态代码块静态代码块被执行静态变量构造器构造器被执行输出如下静态代码块被执行代码说明加载阶段加载类并生成的对象连接阶段进行默认初始化初始化阶段执行方法该方法会依次自动收集类中的所有静态变量的赋值操作和静态代码块中的语句并合并如下静态代码块被执行合并后注意加载类的时候具有同步机制控制如下正因为有这个机制才能保证某个类在内存中只有一份对象二类类在类加载阶段加载文件时会自动创建一个唯一的对象存放在的方法区而每个通过创建的实例对象都知道自己对应的这个对象你写的是图纸加载图纸后自动生成图纸说明书对象用图纸造出来的具体汽车每个都带着说明书索引卡所有汽车都指向同一份唯一的说明书对象能通过找到说明书也是一个类其类名就叫因此它也继承类类对象不是由我们程序员创建出来的而是在类加载时由自动创建的在堆内存中最多只会存在某个类的唯一的对象因为类只会加载一次每个类的实例对象都会知道自己对应的对象通过类对象可以完整地得到其对应的类的信息通过一系列反射类的字节码二进制数据是存放在方法区的又称为类的元数据包括方法代码变量名方法名访问权限等等除了等基本类型外的其他类型全部都是包括例如仔细思考我们可以得出结论类包括接口的本质是数据类型无继承关系的数据类型无法赋值编译成功编译错误而类是由在执行过程中动态加载的在第一次读取到一种类时会将其加载进内存每加载一种就为其创建一个类的对象并将两者关联起来注意这里的类是一个名字叫的类它长这样以类为例当加载类时它首先读取文件到内存然后在堆中为类创建一个类对象并将两者关联起来注意这个类对象是内部创建的如果我们查看源码可以发现类的构造方法是即只有能创建类对象我们程序员自己的程序是无法创建类对象的类的源码里没有任何创建对象的代码对象的创建完全是的自发行为和类本身的代码逻辑无关具体创建时机加载类时类加载阶段当需要使用某个类比如时会执行类加载流程流程的最后一步就是自动创建该类对应的对象并存放在的方法区元空间以类为例创建流程是启动时会默认加载类因为是核心基础类必须提前加载读取文件字节码文件解析里面的元信息类名字段方法等底层调用类的私有构造方法创建一个对象把这个对象存到方法区后续所有实例都通过指针指向它所以持有的每个类对象都指向一个数据类型或一个类对象包含了其对应的类的所有完整信息由于为每个加载的类创建了对应的类对象并在实例中保存了该类的所有信息包括类名包名父类实现的接口所有方法字段等因此如果获取了某个类对象我们就可以通过这个类对象获取到其对应的类的所有信息这种通过实例获取类信息的方法称为反射如何获取一个的实例有个方法方法一直接通过一个类中的静态变量获取是类中的一个静态变量方法二如果我们有一个类的对象可以通过该对象引用提供的方法获取调用类对象的方法获取方法三如果知道一个类的完整类名可以通过类的静态方法获取是类的完整类名方法四对于基本数据类型等通过基本数据类型获取方法五对于基本数据类型对应的包装类可以通过类中的静态变量获取到类对象注意对于基本数据类型获取到的类对象和基本数据类型对应的包装类获取到的类对象是同一个类对象两者相等说明都是指向因为类对象在中是唯一的所以上述方法获取的类对象是同一个对象可以用比较两个类对象注意一下用比较类对象和用的差别因为是类型因为是类型的子类因为返回因为用不但匹配指定类型还匹配指定类型的子类而用比较类对象可以精确地判断数据类型但不能用作子类型比较通常情况下我们应该用判断数据类型因为面向抽象编程的时候我们不关心具体的子类型只有在需要精确判断一个类型是不是某个的时候我们才使用判断实例因为反射的目的是为了获得某个类的实例对象的信息因此当我们拿到某个对象时可以通过反射直接获取该的信息而不需要使用向下转型要从实例获取获取的基本信息参考下面的代码只是简单示范后面会具体介绍注意到数组例如也是一种类而且不同于它的类名是此外为每一种基本类型如也创建了实例通过访问如果获取到了一个类对象我们就可以通过该类对象来创建其对应类的实例对象获取的类对象通过的类对象创建一个类的实例对象上述代码相当于通过可以创建类的实例对象它的局限是只能调用的无参数构造方法带参数的构造方法或者非的构造方法都无法通过被调用动态加载在执行程序的时候并不是一次性把所有用到的全部加载到内存而是第一次需要用到时才加载例如当执行时由于用到了类因此首先会把类对应的类对象加载到内存中然而并不会加载除非程序执行到方法发现需要加载类时才会首次加载类对应的类对象如果没有执行方法那么根本就不会被加载这就是动态加载的特性动态加载类的特性对于程序非常重要利用动态加载的特性我们才能在运行期根据条件去加载不同的实现类例如总是优先使用只有当不存在时才使用的利用动态加载特性大致的实现代码如下优先使用这就是为什么我们只需要把的包放到中就会自动使用的原因小结为每个加载的类及接口创建了对应的类对象来保存及的所有信息获取一个类对应的类对象后就可以获取该类的所有信息通过类对象获取信息的方法称为反射总是动态加载可以在运行期根据条件来控制加载类三访问字段对任意的一个实例只要我们获取了它对应的类对象就可以获取它的一切信息我们先看看如何通过类对象获取其对应的类定义的字段信息类提供了以下几个方法来获取字段根据字段名获取某个的包括父类根据字段名获取当前类的某个不包括父类获取所有的包括父类获取当前类的所有不包括父类我们来看一下示例代码获取字段获取继承的字段获取字段上述代码首先获取的实例然后分别获取字段继承的字段以及字段打印出的类似下面一个对象包含了一个字段的所有信息返回字段名称例如返回字段类型也是一个类对象例如返回字段的修饰符它是一个不同的表示不同的含义以类的字段为例它的定义是我们用反射获取该字段的信息代码如下表示类型获取字段值利用反射拿到字段的一个类对象只是第一步我们还可以拿到一个实例对象对应的该字段的值例如对于一个类对象我们可以先拿到其字段对应的再获取这个类对象的字段的值获取上述代码先获取类对应的类对象再通过该类对象获取类对象然后用获取指定类对象的指定字段的值运行代码如果不出意外会得到一个异常这是因为被定义为一个字段正常情况下类无法访问类的字段要修复错误可以将改为或者在调用前先写一句调用的意思是别管这个字段是不是一律允许访问可以试着加上上述语句再运行代码就可以打印出字段的值有童鞋会问如果使用反射可以获取字段的值那么类的封装还有什么意义答案是一般情况下我们总是通过来访问的字段编译器会根据和这些访问权限修饰符决定是否允许访问字段这样就达到了数据封装的目的而反射是一种非常规的用法使用反射首先代码非常繁琐其次它更多地是给工具或者底层框架来使用目的是在不知道目标对象任何信息的情况下获取特定字段的值此外可能会失败如果运行期存在那么它会根据规则进行检查有可能阻止例如某个可能不允许对和开头的的类调用这样可以保证核心库的安全设置字段值通过类对象既然可以获取到指定对象的字段值自然也可以设置字段的值设置字段值是通过实现的其中第一个参数是指定的对象第二个参数是待修改的值示例代码如下获取允许对字段进行访问设置的的值运行上述代码输出的字段从变成了说明通过反射可以直接修改指定对象的字段的值同样的修改非字段需要调用小结的反射提供的类封装了对应的类定义的全部字段的所有信息通过类对象的方法可以获取类对象通过类对象可以获取类定义字段信息通过类对象可以读取或设置某个对象的字段的值如果存在访问限制则需要调用来访问非字段通过反射读写字段是一种非常规的方法它会破坏对象的封装四调用方法我们已经能通过类的类对象获取其对应的类中定义的所有字段信息同样的可以通过类获取所有信息类提供了以下几个方法来获取类中定义的获取某个的包括父类获取当前类的某个不包括父类获取所有的包括父类获取当前类的所有不包括父类我们来看一下示例代码获取方法形参类型为获取继承的方法无参数获取方法形参类型为上述代码首先获取的类对象然后分别获取类中定义的方法继承的方法以及方法打印出的类似一个类对象包含一个方法的所有信息返回方法名称例如返回方法的返回值类型也是一个实例例如返回方法的参数类型是一个数组例如返回方法的修饰符它是一个不同的表示不同的含义调用方法当我们获取到一个类对象时就可以对它进行调用我们以下面的代码为例一般情况下调用类的方法如果用反射来调用方法需要以下代码对象获取方法形参为在对象上调用该方法并获取结果打印调用结果注意到有两个重载方法我们获取的是这个方法即形参类型为且只有一个思考一下如何获取方法对类对象调用方法就相当于调用该方法的第一个参数是实例对象即在哪个实例对象上调用该方法后面的实参要与方法参数的类型一致否则将报错调用静态方法如果获取到的表示一个静态方法调用静态方法时由于无需指定实例对象所以方法传入的第一个参数永远为我们以方法为例获取方法参数为调用该静态方法并获取结果打印调用结果调用非方法和类对象类似对于非方法我们虽然可以通过获取该方法的实例对象但直接对其调用将得到一个异常为了调用非方法我们通过允许其调用同样可能会失败如果运行期存在那么它会根据规则进行检查有可能阻止例如某个可能不允许对和开头的的类调用这样可以保证核心库的安全多态我们来考率这样一种情况一个类定义了方法并且它的子类也重写了方法那么从获取的作用于类对象时调用的方法到底是哪个获取的方法对实例调用方法运行上述代码发现输出的是因此使用反射调用方法时仍然遵循多态原则即总是调用实际类型的重写方法如果存在上述的反射代码实际上相当于小结的反射提供的类对象封装了类定义的全部方法的所有信息通过类对象的方法可以获取类对象通过类对象可以获取方法信息通过类对象可以调用某个对象的方法通过设置来访问非方法通过反射调用方法时仍然遵循多态原则五调用构造方法一般情况下我们通常使用操作符创建新的对象如果通过反射来创建新的对象可以调用提供的方法调用的局限是它只能调用该类的无参构造方法如果构造方法带有参数或者不是就无法直接通过来调用为了调用任意的构造方法的反射提供了类对象它包含一个构造方法的所有信息通过类对象可以创建一个类的实例对象类对象和类对象非常相似不同之处仅在于它是一个构造方法并且调用结果总是返回一个类的实例对象获取构造方法形参为调用构造方法传入的形参必须与构造方法的形参类型相匹配获取构造方法形参为通过实例获取的方法如下获取某个的获取某个获取所有的获取所有注意类对象只含有当前类定义的构造方法和父类无关因此不存在多态的问题同样调用非的时必须首先通过设置允许访问但也可能会失败小结类对象封装了其对应的类定义的构造方法的所有信息通过类对象可以获取类对象通过类对象可以创建一个对应类的实例对象通过设置来访问非构造方法六获取继承方法当我们获取到某个类对象时实际上就获取到了一个类的类型获取到的类对象还可以用类对象的方法获取是因此获取到的最后一种获取的方法是通过传入的完整类名获取这三种方式获取的类对象都是同一个对象因为对每个加载的只创建一个类对象来表示它的类型获取父类的有了类对象我们还可以获取它的父类的类对象运行上述代码可以看到的父类类型是的父类是的父类是除外其他任何非接口的类对象都必定存在一个父类类型获取由于一个类可能实现一个或多个接口通过我们就可以查询到实现的接口类型例如查询实现的接口运行上述代码可知实现的接口有要特别注意方法只返回当前类直接实现的接口类型并不包括其父类实现的接口类型的父类是类实现的接口是此外对所有接口的类对象调用返回的是获取接口的父接口要用输出因为继承自输出因为对接口调用总是返回获取接口的父接口要用如果一个类没有实现任何那么返回空数组继承关系当我们判断一个对象是否是某个类型时正常情况下使用操作符如果是两个类对象要判断一个向上转型是否成立可以调用方法因为可以赋值给因为可以赋值给因为可以赋值给因为不能赋值给小结通过对象可以获取继承关系获取父类类型获取当前类实现的所有接口通过对象的方法可以判断一个向上转型是否可以实现七动态代理我们来比较的类和接口的区别可以实例化类非不能实例化接口所有接口类型的变量总是通过某个实现了接口的类的对象向上转型再赋值给接口类型的变量有没有可能不编写实现类直接在运行期创建某个的实例呢这是可能的因为标准库提供了一种动态代理的机制可以在运行期动态创建某个的实例什么叫运行期动态创建听起来好像很复杂所谓动态代理是和静态相对应的我们来看静态代理代码怎么写一定义接口二编写实现类三创建实例转型为接口并调用这种方式就是我们通常编写代码的方式还有一种方式是动态代码我们仍然先定义了接口但是我们并不去编写实现类而是直接通过提供的一个方法创建了一个接口对象这种没有实现类但是在运行期动态创建了一个接口对象的方式我们称为动态代理提供的动态创建接口对象的方式就叫动态代理一个最简单的动态代理实现如下传入传入要实现的接口传入处理调用方法的在运行期动态创建一个实例的方法如下定义一个实例它负责实现接口的方法调用通过创建实例它需要个参数使用的通常就是接口类的需要实现的接口数组至少需要传入一个接口进去用来处理接口方法调用的实例将返回的强制转型为接口动态代理实际上是在运行期动态创建字节码并加载的过程它并没有什么黑魔法把上面的动态代理改写为静态实现类大概长这样其实就是帮我们自动编写了一个上述类不需要源码可以直接生成字节码并不存在可以直接实例化接口的黑魔法小结标准库提供了动态代理功能允许在运行期动态创建一个接口的实例动态代理是通过创建代理对象然后将接口方法代理给完成的',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-13 23:05:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510132339617.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">zhangzhang-blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BFS/" style="font-size: 1.05rem;">BFS<sup>4</sup></a><a href="/tags/Boyer-Moore/" style="font-size: 1.05rem;">Boyer-Moore<sup>1</sup></a><a href="/tags/DFS/" style="font-size: 1.05rem;">DFS<sup>10</sup></a><a href="/tags/DP/" style="font-size: 1.05rem;">DP<sup>7</sup></a><a href="/tags/Hash/" style="font-size: 1.05rem;">Hash<sup>10</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>47</sup></a><a href="/tags/Kadane-%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">Kadane 算法<sup>1</sup></a><a href="/tags/LeetCode/" style="font-size: 1.05rem;">LeetCode<sup>44</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>1</sup></a><a href="/tags/PTA/" style="font-size: 1.05rem;">PTA<sup>92</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c<sup>28</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c++<sup>74</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/vim/" style="font-size: 1.05rem;">vim<sup>1</sup></a><a href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" style="font-size: 1.05rem;">三指针<sup>5</sup></a><a href="/tags/%E4%B8%B2/" style="font-size: 1.05rem;">串<sup>2</sup></a><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 1.05rem;">二叉树<sup>6</sup></a><a href="/tags/%E4%BD%9C%E4%B8%9A/" style="font-size: 1.05rem;">作业<sup>73</sup></a><a href="/tags/%E5%85%B1%E4%BA%AB%E6%A0%88/" style="font-size: 1.05rem;">共享栈<sup>1</sup></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 1.05rem;">双指针<sup>20</sup></a><a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 1.05rem;">回溯<sup>5</sup></a><a href="/tags/%E5%9B%BE/" style="font-size: 1.05rem;">图<sup>8</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/" style="font-size: 1.05rem;">图床搭建<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>5</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>9</sup></a><a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 1.05rem;">快慢指针<sup>6</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">插件<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>98</sup></a><a href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" style="font-size: 1.05rem;">栈和队列<sup>22</sup></a><a href="/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 1.05rem;">树和二叉树<sup>13</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 1.05rem;">生活<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>3</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>144</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 1.05rem;">线性表<sup>1</sup></a><a href="/tags/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" style="font-size: 1.05rem;">缓存问题<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.05rem;">贪心<sup>2</sup></a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.05rem;">链表<sup>34</sup></a><a href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" style="font-size: 1.05rem;">阿里云<sup>1</sup></a><a href="/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/" style="font-size: 1.05rem;">顺序表<sup>19</sup></a><a href="/tags/%E9%A9%BE%E7%85%A7/" style="font-size: 1.05rem;">驾照<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">64</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">74</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" itemprop="url">笔记整理</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java中的反射机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-13T15:02:00.000Z" title="发表于 2025-12-13 23:02:00">2025-12-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-13T15:05:46.492Z" title="更新于 2025-12-13 23:05:46">2025-12-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">9.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="java中的反射机制"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为武汉"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>武汉</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=52fea558-31d3-279e-541b-87c730ca6dde"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"><header><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" itemprop="url">笔记整理</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><h1 id="CrawlerTitle" itemprop="name headline">java中的反射机制</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">zhangzhang</span><time itemprop="dateCreated datePublished" datetime="2025-12-13T15:02:00.000Z" title="发表于 2025-12-13 23:02:00">2025-12-13</time><time itemprop="dateCreated datePublished" datetime="2025-12-13T15:05:46.492Z" title="更新于 2025-12-13 23:05:46">2025-12-13</time></header><h2 id="一、反射概述"><a href="#一、反射概述" class="headerlink" title="一、反射概述"></a>一、反射概述</h2><h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h3><p><strong>反射（<code>Reflection</code>），Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信息。</strong></p>
<p><strong>反射机制</strong>一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题。</p>
<h3 id="2-反射机制原理"><a href="#2-反射机制原理" class="headerlink" title="2. 反射机制原理"></a>2. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=反射机制&spm=1001.2101.3001.7020">反射机制</a>原理</h3><p>反射机制允许 Java 程序在运行时调用<code>Reflection API</code>取得任何类的内部信息（比如成员变量、构造器、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=成员方法&spm=1001.2101.3001.7020">成员方法</a>等），并能操作类的实例对象的属性以及方法。</p>
<p>在Java 程序中，<code>JVM</code> 加载完一个类后，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=堆内存&spm=1001.2101.3001.7020">堆内存</a>中就会产生该类的一个 <code>Class</code> 对象，一个类在堆内存中最多只会有一个 <code>Class</code> 对象，这个<code>Class</code> 对象包含了该类的<strong>完整结构信息</strong>，我们通过这个 <code>Class</code> 对象便可以得到该类的<strong>完整结构信息</strong>。</p>
<p>这个 <code>Class</code> 对象就像是一面镜子，我们透过这面镜子可以清楚地看到类的结构信息。因此，我们形象的将获取<code>Class</code>对象的过程称为：<strong>反射</strong>。</p>
<p>==Java 反射机制原理示意图：==</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202512132303785.png" alt="在这里插入图片描述"></p>
<h3 id="3-反射优点和缺点"><a href="#3-反射优点和缺点" class="headerlink" title="3. 反射优点和缺点"></a>3. 反射优点和缺点</h3><blockquote>
<ol>
<li><strong>优点：可以<code>动态</code>地创建和使用对象，反射机制是 Java 框架的底层核心，其使用灵活，没有反射机制，底层框架就失去支撑。</strong></li>
<li><strong>缺点：使用反射基本是解释执行，对程序执行速度有影响。</strong></li>
</ol>
</blockquote>
<h3 id="4-类加载概述"><a href="#4-类加载概述" class="headerlink" title="4. 类加载概述"></a>4. 类加载概述</h3><p>==在深入讲解反射前，先来介绍一下 Java中类的加载与反射机制。==</p>
<blockquote>
<p><strong>反射机制是 Java实现动态语言的关键，也就是通过反射实现类的动态加载。</strong></p>
<blockquote>
<ol>
<li>静态加载：编译时就加载相关的类，如果程序中不存在该类则编译报错，依赖性太强。</li>
<li>动态加载：运行时加载相关的类，即使程序中不存在该类，但如果运行时未使用到该类，也不会编译错误，依赖性较弱。</li>
</ol>
</blockquote>
</blockquote>
<p>==举个例子：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">switch</span>(key) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// 通过反射创建一个Dog 类对象，不提供代码，只是文字说明</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，根据 key 的值选择创建 Cat/Dog 对象，但是在代码编译时，编译器会先检查程序中是否存在 Cat 类，如果没有，则会编译报错；编译器不会检查是否存在 Dog 类，因为 Dog 类是使用反射的方式创建的，所以即使程序中不存在 Dog 类，也不会编译报错，而是等到程序运行时，我们真正选择了 key = 1 后，才会去检查 Dog 类是否存在。</li>
</ul>
<blockquote>
<p><strong>类加载的时机：</strong></p>
<blockquote>
<ol>
<li><strong>静态加载</strong></li>
</ol>
<blockquote>
<ul>
<li>当新创建一个对象时（new）,该类会被加载；</li>
<li>当调用类中的静态成员时，该类会被加载；</li>
<li>当子类被加载时，其超类也会被加载；</li>
</ul>
</blockquote>
<ol>
<li><strong>动态加载</strong></li>
</ol>
<blockquote>
<ul>
<li>通过反射的方式，在程序运行时使用到哪个类，该类才会被加载；</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<p>==类加载的过程图：==</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202512132303903.png" alt="在这里插入图片描述"></p>
<h3 id="5-类加载各阶段完成的功能"><a href="#5-类加载各阶段完成的功能" class="headerlink" title="5. 类加载各阶段完成的功能"></a>5. 类加载各阶段完成的功能</h3><blockquote>
<ol>
<li><strong>加载阶段：将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象，此过程由类加载器完成。</strong></li>
<li><strong>连接阶段：又分为验证、准备、解析三个小阶段，此阶段会将类的二进制数据合并到 JRE 中。</strong></li>
<li><strong>初始化阶段：JVM 负责对类的<code>静态成员</code>进行初始化。</strong></li>
</ol>
</blockquote>
<p>==<strong>如下图所示：</strong>==</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202512132303916.png" alt="在这里插入图片描述"></p>
<h4 id="5-1-加载阶段"><a href="#5-1-加载阶段" class="headerlink" title="5.1 加载阶段"></a>5.1 加载阶段</h4><blockquote>
<p><strong>JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、jar 包、甚至网络文件）转换为<code>二进制字节流</code>加载到内存中，并生成一个代表该类的 java.lang.Class 对象。</strong></p>
</blockquote>
<h4 id="5-2-连接阶段——验证"><a href="#5-2-连接阶段——验证" class="headerlink" title="5.2 连接阶段——验证"></a>5.2 连接阶段——验证</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202512132303397.png" alt="在这里插入图片描述"></p>
<h4 id="5-3-连接阶段——准备"><a href="#5-3-连接阶段——准备" class="headerlink" title="5.3 连接阶段——准备"></a>5.3 连接阶段——准备</h4><blockquote>
<p><strong>JVM 会在该阶段对静态变量分配内存并进行默认初始化（不同数据类型会有其默认初始值，如：int —- 0，boolean —- false 等）。这些变量的内存空间会在方法区中分配。</strong></p>
</blockquote>
<p>==举例如下：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 属性=成员变量=字段</span></span><br><span class="line">    	<span class="comment">// 类加载的连接阶段-准备，属性是如何加载的</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码说明：<ol>
<li>n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</li>
<li>n2 是静态变量，在该阶段 JVM 会为其分配内存，n2 默认初始化的值为 0 ,而不是 20</li>
<li>n3 被 static final 修饰，是常量, 它和静态变量不一样, 其一旦赋值后值就不变，因此其默认初始化 n3 = 30</li>
</ol>
</li>
</ul>
<h4 id="5-4-连接阶段——解析"><a href="#5-4-连接阶段——解析" class="headerlink" title="5.4 连接阶段——解析"></a>5.4 连接阶段——解析</h4><p>JVM 将常量池内的符号引用替换为直接引用的过程。</p>
<h4 id="5-5-初始化阶段"><a href="#5-5-初始化阶段" class="headerlink" title="5.5 初始化阶段"></a>5.5 初始化阶段</h4><blockquote>
<ol>
<li><strong>在初始化阶段，JVM 才会真正执行类中定义的 Java程序代码，此阶段是执行<clinit>() 方法的过程。</strong></li>
<li><strong><clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<code>静态变量</code>的赋值操作和<code>静态代码块</code>中的语句，并进行合并的过程。</strong></li>
<li><strong>JVM 会保证一个类的 <clinit>() 方法 在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法，其他线程都要阻塞等待，直到活动线程执行 <clinit>() 方法完毕。</strong></li>
</ol>
</blockquote>
<p>==举例如下：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(B.num);<span class="comment">// 直接使用类的静态属性，也会导致类的加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// 静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">        num = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;<span class="comment">// 构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==输出如下：==</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B 静态代码块被执行</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码说明：</strong></p>
<blockquote>
<ol>
<li><strong>加载阶段：加载 B类，并生成 B的 class对象</strong></li>
<li><strong>连接阶段：进行默认初始化 num = 0</strong></li>
<li><strong>初始化阶段：执行 <code>&lt;clinit&gt;() 方法</code>，该方法会依次自动收集类中的所有<code>静态变量</code>的赋值操作和<code>静态代码块</code>中的语句,并合并。如下：</strong></li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clinit() &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">    num = <span class="number">300</span>;</span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>合并后: num = 100</li>
</ul>
<blockquote>
<p><strong>注意：加载类的时候，具有同步机制控制。如下：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	<span class="comment">//正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">    	<span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Class-类"><a href="#二、Class-类" class="headerlink" title="二、Class 类"></a>二、Class 类</h2><p><strong><code>Cat</code> 类在「类加载阶段」（JVM 加载 <code>Cat.class</code> 文件时），会自动创建一个唯一的 <code>Class&lt;Cat&gt;</code> 对象（存放在 JVM 的方法区）；而每个通过 <code>new Cat()</code> 创建的 <code>Cat</code> 实例对象，都 “知道” 自己对应的这个 <code>Class&lt;Cat&gt;</code> 对象</strong></p>
<ul>
<li>你写的 <code>class Cat&#123;&#125;</code> 是 “图纸”；</li>
<li>JVM 加载图纸后，自动生成 “图纸说明书”（<code>Class&lt;Cat&gt;</code> 对象）；</li>
<li>用图纸造出来的 “具体汽车”（<code>new Cat()</code>），每个都带着 ‘说明书索引卡’”—— 所有汽车都指向同一份唯一的说明书（<code>Class&lt;Cat&gt;</code> 对象）（能通过 <code>getClass()</code> 找到说明书）。</li>
</ul>
<ol>
<li><code>Class</code>也是一个类，其类名就叫<code>Class</code>，因此它也继承 Object 类</li>
<li><code>Class</code>类对象不是由我们程序员创建（new）出来的，而是在类加载时由 JVM 自动创建的</li>
<li>在<code>堆内存</code>中最多只会存在某个类的唯一的<code>Class</code>对象，因为类只会加载一次</li>
<li>每个类的实例对象都会知道自己对应的<code>Class</code>对象</li>
<li>通过<code>Class</code>类对象可以完整地得到其对应的类的信息，通过一系列反射 API</li>
<li>类的字节码二进制数据，是存放在方法区的，又称为<code>类的元数据</code>（包括方法代码、变量名、方法名、访问权限等等）</li>
</ol>
<p><strong>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</strong></p>
<ul>
<li><code>String</code></li>
<li><code>Object</code></li>
<li><code>Runnable</code></li>
<li><code>Exception</code></li>
<li>…</li>
</ul>
<blockquote>
<p>仔细思考，我们可以得出结论：类<code>class</code>（包括接口<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// 编译成功</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">123.456</span>); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>而类<code>class</code>是由 JVM 在执行过程中==动态加载==的。JVM在第一次读取到一种类<code>class</code>时，会将其加载进内存。</p>
</blockquote>
<blockquote>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类的对象，并将两者关联起来。注意：这里的<code>Class</code>类是一个名字叫<code>Class</code>的类<code>class</code>。它长这样：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以<code>String</code>类为例，当 JVM 加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，在堆中为<code>String</code>类创建一个<code>Class</code>类对象并将两者关联起来：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：这个<code>Class</code>类对象是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，即只有 JVM 能创建<code>Class</code>类对象，我们程序员自己的 Java 程序是无法创建<code>Class</code>类对象的。</p>
<ul>
<li><p><code>String</code> 类的源码里，没有任何 “创建 <code>Class&lt;String&gt;</code> 对象” 的代码 ——<code>Class&lt;String&gt;</code> 对象的创建，完全是 JVM 的 “自发行为”，和 <code>String</code> 类本身的代码逻辑无关。</p>
<h4 id="具体创建时机：JVM-加载类时（类加载阶段）"><a href="#具体创建时机：JVM-加载类时（类加载阶段）" class="headerlink" title="具体创建时机：JVM 加载类时（类加载阶段）"></a>具体创建时机：JVM 加载类时（类加载阶段）</h4><p>当 JVM 需要使用某个类（比如 <code>String</code>、<code>Cat</code>）时，会执行「类加载流程」，流程的最后一步就是：<strong>JVM 自动创建该类对应的 <code>Class</code> 对象</strong>，并存放在 JVM 的「方法区」（元空间）。</p>
<p>以 <code>String</code> 类为例，创建流程是：</p>
<ol>
<li>JVM 启动时，会默认加载 <code>java.lang.String</code> 类（因为 String 是核心基础类，必须提前加载）；</li>
<li>JVM 读取 <code>String.class</code> 文件（字节码文件），解析里面的元信息（类名、字段、方法等）；</li>
<li>JVM 底层调用 <code>Class</code> 类的私有构造方法（<code>private Class()</code>），创建一个 <code>Class&lt;String&gt;</code> 对象；</li>
<li>把这个 <code>Class&lt;String&gt;</code> 对象存到方法区，后续所有 <code>String</code> 实例（<code>new String(&quot;abc&quot;)</code>）都通过 “指针” 指向它。</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以，JVM持有的每个<code>Class</code>类对象都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个<code>Class</code>类对象包含了其对应的类<code>class</code>的所有完整信息：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package = &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super = &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface = CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>由于JVM为每个加载的类<code>class</code>创建了对应的<code>Class</code>类对象，并在实例中保存了该类<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，<strong>因此</strong>，如果获取了某个<code>Class</code>类对象，我们就可以通过这个<code>Class</code>类对象获取到其对应的类<code>class</code>的所有信息。</p>
<p><strong>这种通过<code>Class</code>实例获取类<code>class</code>信息的方法称为反射（Reflection）。</strong></p>
<p><strong>如何获取一个<code>class</code>的<code>Class</code>实例？有5个方法：</strong></p>
<blockquote>
<p>方法一：直接通过一个类<code>class</code>中的静态变量<code>class</code>获取：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;<span class="comment">// class 是 String 类中的一个静态变量</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法二：如果我们有一个类<code>class</code>的对象，可以通过该对象引用提供的<code>getClass()</code>方法获取：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass();<span class="comment">// 调用 String类对象 s的 getClass() 方法获取</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法三：如果知道一个类<code>class</code>的完整类名，可以通过<code>Class</code>类的静态方法<code>Class.forName()</code>获取：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);<span class="comment">// java.lang.String 是 String 类的完整类名</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法四：对于基本数据类型（int、char、boolean、float 等），通过 基本数据类型.class 获取：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">integerClass</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">characterClass</span> <span class="operator">=</span> <span class="type">char</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">booleanClass</span> <span class="operator">=</span> <span class="type">boolean</span>.class;</span><br><span class="line">System.out.println(integerClass);<span class="comment">// int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法五：对于基本数据类型对应的包装类，可以通过类中的静态变量<code>TYPE</code>获取到<code>Class</code>类对象：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">type1</span> <span class="operator">=</span> Integer.TYPE;</span><br><span class="line"><span class="type">Class</span> <span class="variable">type2</span> <span class="operator">=</span> Character.TYPE;</span><br><span class="line">System.out.println(type1);<span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：对于基本数据类型获取到的<code>Class</code>类对象和基本数据类型对应的包装类获取到的<code>Class</code>类对象，是同一个<code>Class</code>类对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(integerClass.hashCode());</span><br><span class="line">System.out.println(type1.hashCode());<span class="comment">// 两者相等，说明都是指向 int</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>因为<code>Class</code>类对象在 JVM 中是唯一的，所以，上述方法获取的<code>Class</code>类对象是同一个对象。可以用<code>==</code>比较两个<code>Class</code>类对象：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> String.class;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">sameClass</span> <span class="operator">=</span> cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意一下用<code>==</code>比较<code>Class</code>类对象和用<code>instanceof</code>的差别：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为 n是 Integer  类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为 n 是 Number 类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为 n.getClass() 返回 Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为 Integer.class != Number.class</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>用instanceof</p>
<p>不但匹配指定类型，还匹配指定类型的子类。而用==比较class类对象可以精确地判断数据类型，但不能用作子类型比较。</p>
<ul>
<li>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。</li>
<li>只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>因为反射的目的是为了获得某个类的实例对象的信息。因此，当我们拿到某个<code>Object</code>对象时，可以通过反射直接获取该<code>Object</code>的<code>class</code>信息，而不需要使用<code>向下转型</code>：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printObjectInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码（只是简单示范，后面会具体介绍）：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意到数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。此外，JVM为每一种基本类型如<code>int</code>也创建了<code>Class</code>实例，通过<code>int.class</code>访问。</li>
</ul>
<blockquote>
<p>如果获取到了一个<code>Class</code>类对象，我们就可以通过该<code>Class</code>类对象来创建其对应类的实例对象：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 String 的 Class 类对象:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 通过 String 的 Class 类对象创建一个 String 类的实例对象:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类的实例对象，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</li>
</ul>
<h3 id="1-动态加载"><a href="#1-动态加载" class="headerlink" title="1. 动态加载"></a>1. 动态加载</h3><blockquote>
<p><strong>JVM在执行 Java程序的时候，并不是一次性把所有用到的<code>class</code>全部加载到内存，而是第一次需要用到<code>class</code>时才加载。例如：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当执行<code>Main.java</code>时，由于用到了<code>Main</code>类，因此，JVM 首先会把<code>Main</code>类对应的<code>Class</code>类对象<code>Main.class</code>加载到内存中。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM 发现需要加载<code>Person</code>类时，才会首次加载<code>Person</code>类对应的<code>Class</code>类对象<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</li>
<li>这就是 JVM动态加载<code>class</code>的特性。</li>
</ul>
<blockquote>
<p><strong>动态加载类<code>class</code>的特性对于 Java 程序非常重要。利用 JVM 动态加载<code>class</code>的特性，我们才能在运行期根据条件去加载不同的实现类。例如，Commons Logging 总是优先使用 Log4j，只有当 Log4j 不存在时，才使用 JDK 的 logging。利用 JVM 动态加载特性，大致的实现代码如下：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这就是为什么我们只需要把 Log4j 的 jar 包放到 classpath 中，Commons Logging 就会自动使用 Log4j 的原因。</li>
</ul>
<h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><ol>
<li>JVM为每个加载的类<code>class</code>及接口<code>interface</code>创建了对应的<code>Class</code>类对象来保存<code>class</code>及<code>interface</code>的所有信息；</li>
<li>获取一个类<code>class</code>对应的<code>Class</code>类对象后，就可以获取该类<code>class</code>的所有信息；</li>
<li>通过 Class类对象获取<code>class</code>信息的方法称为反射（Reflection）；</li>
<li>JVM 总是动态加载<code>class</code>，可以在运行期根据条件来控制加载类<code>class</code>。</li>
</ol>
<h2 id="三、访问字段"><a href="#三、访问字段" class="headerlink" title="三、访问字段"></a>三、访问字段</h2><p><strong>对任意的一个<code>Object</code>实例，只要我们获取了它对应的<code>Class</code>类对象，就可以获取它的一切信息。</strong></p>
<blockquote>
<p><strong>我们先看看如何通过<code>Class</code>类对象获取其对应的类定义的字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</strong></p>
<blockquote>
<ol>
<li><code>Field getField(name)</code>：根据字段名获取某个 public 的 field（包括父类）</li>
<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li>
<li><code>Field[] getFields()</code>：获取所有 public 的 field（包括父类）</li>
<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li>
</ol>
</blockquote>
</blockquote>
<p>==我们来看一下示例代码：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似下面：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Student.grade</span><br></pre></td></tr></table></figure>

<ul>
<li>一个<code>Field</code>对象包含了一个字段的所有信息：<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>类对象，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的 bit 表示不同的含义。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>我们用反射获取该字段的信息，代码如下：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="1-获取字段值"><a href="#1-获取字段值" class="headerlink" title="1. 获取字段值"></a>1. 获取字段值</h3><p><strong>利用反射拿到字段的一个<code>Field</code>类对象只是第一步，我们还可以拿到一个实例对象对应的该字段的值。</strong></p>
<blockquote>
<p><strong>例如，对于一个<code>Person</code>类对象，我们可以先拿到其<code>name</code>字段对应的<code>Field</code>，再获取这个<code>Person</code>类对象的<code>name</code>字段的 值：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">// 获取 private String name;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码先获取<code>Person</code>类对应的<code>Class</code>类对象，再通过该<code>Class</code>类对象获取<code>Field</code>类对象，然后，用<code>Field.get(Object)</code>获取指定<code>Person</code>类对象的指定字段的值。</li>
<li>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>异常，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</li>
<li>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</li>
</ul>
<p><strong>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</strong></p>
<ul>
<li>答案是一般情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>这些访问权限修饰符决定是否允许访问字段，这样就达到了数据封装的目的。</li>
<li>而反射是一种非常规的用法，使用反射，首先代码非常繁琐；其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标对象任何信息的情况下，获取特定字段的值。</li>
</ul>
<p><strong>此外，<code>setAccessible(true)</code>可能会失败。</strong> 如果 JVM 运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。</p>
<h3 id="2-设置字段值"><a href="#2-设置字段值" class="headerlink" title="2. 设置字段值"></a>2. 设置字段值</h3><p><strong>通过 Field 类对象既然可以获取到指定对象的字段值，自然也可以设置字段的值。</strong></p>
<blockquote>
<p><strong>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的对象，第二个<code>Object</code>参数是待修改的值。示例代码如下：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> p.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;name&quot;</span>);<span class="comment">// 获取 private String name;</span></span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);<span class="comment">// 允许对 private 字段进行访问</span></span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);<span class="comment">// 设置 p 的 name 的值</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行上述代码，输出的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改指定对象的字段的值。</li>
<li>同样的，修改非<code>public</code>字段，需要调用<code>setAccessible(true)</code>。</li>
</ul>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ol>
<li>Java 的反射 API 提供的<code>Field</code>类封装了对应的类定义的全部字段的所有信息：</li>
<li>通过<code>Class</code>类对象的方法可以获取<code>Field</code>类对象：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</li>
<li>通过<code>Field</code>类对象可以获取类定义字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</li>
<li>通过<code>Field</code>类对象可以<code>读取或设置</code>某个对象的字段的值，如果存在访问限制，则需要调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</li>
<li>通过反射读写字段是一种非常规的方法，它会破坏对象的封装。</li>
</ol>
<h2 id="四、调用方法"><a href="#四、调用方法" class="headerlink" title="四、调用方法"></a>四、调用方法</h2><blockquote>
<p><strong>我们已经能通过<code>Class</code>类的<code>Field</code>类对象获取其对应的类<code>class</code>中定义的所有字段信息，同样的，可以通过<code>Class</code>类获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取类<code>class</code>中定义的<code>Method</code>：</strong></p>
<blockquote>
<ol>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ol>
</blockquote>
</blockquote>
<p>==我们来看一下示例代码：==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">stdClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 获取 public方法 getScore，形参类型为 String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的 public方法 getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取 private方法 getGrade，形参类型为 int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="type">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码首先获取<code>Student</code>的<code>Class</code>类对象，然后，分别获取<code>Student</code>类中定义的<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> Student.getGrade(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>一个<code>Method</code>类对象包含一个方法的所有信息：</strong></p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法的返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的 bit 表示不同的含义。</li>
</ul>
<h3 id="1-调用方法"><a href="#1-调用方法" class="headerlink" title="1. 调用方法"></a>1. 调用方法</h3><blockquote>
<p><strong>当我们获取到一个<code>Method</code>类对象时，就可以对它进行调用。我们以下面的代码为例：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况下调用 String 类的 substring() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果用反射来调用<code>substring</code>方法，需要以下代码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String 对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取 String substring(int)方法，形参为 int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在 s 对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法（即形参类型为 int，且只有一个）。思考一下如何获取<code>String substring(int, int)</code>方法。</li>
<li>对<code>Method</code>类对象调用<code>invoke</code>方法就相当于调用该<code>substring(int)</code>方法，<code>invoke</code>的第一个参数是实例对象（即在哪个实例对象上调用该方法），后面的实参要与方法参数的类型一致，否则将报错。</li>
</ul>
<h3 id="2-调用静态方法"><a href="#2-调用静态方法" class="headerlink" title="2. 调用静态方法"></a>2. 调用静态方法</h3><blockquote>
<p><strong>如果获取到的<code>Method</code>表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>方法为例：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取 Integer.parseInt(String) 方法，参数为 String:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> (Integer) m.invoke(<span class="literal">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);<span class="comment">// 12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-调用非-public方法"><a href="#3-调用非-public方法" class="headerlink" title="3. 调用非 public方法"></a>3. 调用非 public方法</h3><blockquote>
<p><strong>和<code>Field</code>类对象类似，对于非 public 方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法的实例对象，但直接对其调用将得到一个<code>IllegalAccessException</code>异常。为了调用非 public 方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);<span class="comment">// Bob</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样，<code>setAccessible(true)</code>可能会失败。如果 JVM 运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。</li>
</ul>
<h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><blockquote>
<p><strong>我们来考率这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也重写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>类对象时，调用的<code>hello()</code>方法到底是哪个？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Person的 hello方法:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">h</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对 Student实例调用 hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行上述代码，发现输出的是<code>Student:hello</code>，因此，使用反射调用方法时，<strong>仍然遵循多态原则：即总是调用实际类型的重写方法（如果存在）。</strong> 上述的反射代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>实际上相当于：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>

<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><ol>
<li>Java 的反射 API 提供的<code>Method</code>类对象封装了类定义的全部方法的所有信息：</li>
<li>通过<code>Class</code>类对象的方法可以获取<code>Method</code>类对象：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</li>
<li>通过<code>Method</code>类对象可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</li>
<li>通过<code>Method</code>类对象可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</li>
<li>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</li>
<li>通过反射调用方法时，仍然遵循多态原则。</li>
</ol>
<h2 id="五、调用构造方法"><a href="#五、调用构造方法" class="headerlink" title="五、调用构造方法"></a>五、调用构造方法</h2><blockquote>
<p><strong>一般情况下，我们通常使用<code>new</code>操作符创建新的对象：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果通过反射来创建新的对象，可以调用<code>Class</code>提供的<code>newInstance()</code>方法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>Class.newInstance()</code>的局限是，它只能调用该类的<code>public</code>无参构造方法。如果构造方法带有参数，或者不是<code>public</code>，就无法直接通过<code>Class.newInstance()</code>来调用。</li>
</ul>
<blockquote>
<p><strong>为了调用任意的构造方法，Java 的反射 API 提供了<code>Constructor</code>类对象，它包含一个构造方法的所有信息，通过<code>Constructor</code>类对象可以创建一个类的实例对象。<code>Constructor</code>类对象和<code>Method</code>类对象非常相似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回一个类的实例对象：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法 Integer(int)，形参为 int</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="comment">// 传入的形参必须与构造方法的形参类型相匹配</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)，形参为 String</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> Integer.class.getConstructor(String.class);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>通过Class实例获取Constructor的方法如下：</strong></p>
<ol>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ol>
<p><strong>注意：<code>Constructor</code>类对象只含有当前类定义的构造方法，和父类无关，因此不存在多态的问题。</strong></p>
<p>同样，调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。但<code>setAccessible(true)</code>也可能会失败。</p>
<p><strong>小结</strong></p>
<ol>
<li><code>Constructor</code>类对象封装了其对应的类定义的构造方法的所有信息；</li>
<li>通过<code>Class</code>类对象可以获取<code>Constructor</code>类对象：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</li>
<li>通过<code>Constructor</code>类对象可以创建一个对应类的实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</li>
</ol>
<h2 id="六、获取继承方法"><a href="#六、获取继承方法" class="headerlink" title="六、获取继承方法"></a>六、获取继承方法</h2><blockquote>
<p><strong>当我们获取到某个<code>Class</code>类对象时，实际上就获取到了一个类的类型：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class; <span class="comment">// 获取到 String 的 Class类对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>还可以用类对象的<code>getClass()</code>方法获取：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这三种方式获取的<code>Class</code>类对象都是同一个对象，因为 JVM 对每个加载的<code>Class</code>只创建一个<code>Class</code>类对象来表示它的类型。</p>
<h3 id="1-获取父类的Class"><a href="#1-获取父类的Class" class="headerlink" title="1. 获取父类的Class"></a>1. 获取父类的Class</h3><p>有了<code>Class</code>类对象，我们还可以获取它的父类的<code>Class</code>类对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非接口<code>interface</code>的<code>Class</code>类对象都必定存在一个父类类型。</li>
</ul>
<h3 id="2-获取interface"><a href="#2-获取interface" class="headerlink" title="2. 获取interface"></a>2. 获取interface</h3><blockquote>
<p><strong>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行上述代码可知，<code>Integer</code>实现的接口有：</strong></p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<blockquote>
<p><strong>要特别注意：<code>getInterfaces()</code>方法只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>类实现的接口是<code>java.io.Serializable</code>。</li>
</ul>
<blockquote>
<p><strong>此外，对所有接口<code>interface</code>的<code>Class</code>类对象调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); </span><br><span class="line"><span class="comment">// 输出 java.io.FilterInputStream。因为 DataInputStream 继承自 FilterInputStream</span></span><br><span class="line"></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); </span><br><span class="line"><span class="comment">// 输出 null。因为对接口调用 getSuperclass()总是返回 null，获取接口的父接口要用 getInterfaces()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</li>
</ul>
<h3 id="3-继承关系"><a href="#3-继承关系" class="headerlink" title="3. 继承关系"></a>3. 继承关系</h3><blockquote>
<p><strong>当我们判断一个对象是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDouble</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInteger</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNumber</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSerializable</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果是两个<code>Class</code>类对象，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>方法：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>

<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ol>
<li>通过<code>Class</code>对象可以获取继承关系：<ul>
<li><code>Class getSuperclass()</code>：获取父类类型；</li>
<li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li>
</ul>
</li>
<li>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</li>
</ol>
<h2 id="七、动态代理"><a href="#七、动态代理" class="headerlink" title="七、动态代理"></a>七、动态代理</h2><p><strong>我们来比较 Java 的类<code>class</code>和接口<code>interface</code>的区别：</strong></p>
<ul>
<li>可以实例化类<code>class</code>（非<code>abstract</code>）；</li>
<li>不能实例化接口<code>interface</code>。</li>
</ul>
<blockquote>
<p><strong>所有接口<code>interface</code>类型的变量总是通过某个实现了接口的类的对象向上转型再赋值给接口类型的变量：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p>
<p><strong>这是可能的，因为 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</strong></p>
<p><strong>什么叫<code>运行期动态创建</code>？听起来好像很复杂。所谓<code>动态代理</code>，是和静态相对应的。我们来看静态代理代码怎么写：</strong></p>
<blockquote>
<p><strong>一、定义接口：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>二、编写实现类：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>三、创建实例，转型为接口并调用：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式就是我们通常编写代码的方式。</li>
</ul>
<p><strong>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过 JDK 提供的一个<code>Proxy.newProxyInstance()</code>方法创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为<code>动态代理</code>。JDK 提供的动态创建接口对象的方式，就叫<code>动态代理</code>。</strong></p>
<p>一个最简单的动态代理实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在运行期动态创建一个<code>interface</code>实例的方法如下：</strong></p>
<ol>
<li><p>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</p>
</li>
<li><p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance()</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface</span><br></pre></td></tr></table></figure>

<p>实例，它需要3个参数：</p>
<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li><p>将返回的<code>Object</code>强制转型为接口。</p>
</li>
</ol>
<blockquote>
<p><strong>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="built_in">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其实就是 JVM 帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</li>
</ul>
<p><strong>小结</strong></p>
<ol>
<li>Java 标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</li>
<li>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510132339315.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510132339315.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">zhangzhang</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/')">java中的反射机制</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java中的反射机制&amp;url=http://example.com/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/&amp;pic=https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=52fea558-31d3-279e-541b-87c730ca6dde" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">zhangzhang-blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">47</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=21271dad-a56a-3206-d7d2-1c4a61b9d4b7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/12/13/%EF%BC%88LeetCodeHot100%EF%BC%8964.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E2%80%94%E2%80%94minimum-path-sum/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=65ac5f6e-4835-5655-bbf8-cd5fedb73320" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">（LeetCodeHot100）64. 最小路径和——minimum-path-sum</div></div></a></div><div class="next-post pull-right"><a href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8972.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E2%80%94%E2%80%94edit-distance/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=b7a91123-13a6-8acd-6f43-cf27814fdd17" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">（LeetCodeHot100）72. 编辑距离——edit-distance</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/11/10/%EF%BC%88LeetCodeHot100%EF%BC%891.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E2%80%94%E2%80%94two-sum/" title="（LeetCodeHot100）1. 两数之和——two-sum"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=a145f153-e811-38af-d970-86daf75fa801" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-10</div><div class="title">（LeetCodeHot100）1. 两数之和——two-sum</div></div></a></div><div><a href="/2025/11/11/%EF%BC%88LeetCodeHot100%EF%BC%89101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94symmetric-tree/" title="（LeetCodeHot100）101. 对称二叉树——symmetric-tree"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=a0cdf50d-eb18-1ecd-2ba1-f27ec4b08a12" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-11</div><div class="title">（LeetCodeHot100）101. 对称二叉树——symmetric-tree</div></div></a></div><div><a href="/2025/11/11/%EF%BC%88LeetCodeHot100%EF%BC%89104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E2%80%94%E2%80%94maximum-depth-of-binary-tree/" title="（LeetCodeHot100）104. 二叉树的最大深度——maximum-depth-of-binary-tree"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=460bf896-9c39-ba7a-a89e-349a1f25b153" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-11</div><div class="title">（LeetCodeHot100）104. 二叉树的最大深度——maximum-depth-of-binary-tree</div></div></a></div><div><a href="/2025/11/19/%EF%BC%88LeetCodeHot100%EF%BC%8911.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94container-with-most-water/" title="（LeetCodeHot100）11. 盛最多水的容器——container-with-most-water"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=53995b07-5c27-c515-b4d0-5599a8d400f5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-19</div><div class="title">（LeetCodeHot100）11. 盛最多水的容器——container-with-most-water</div></div></a></div><div><a href="/2025/11/12/%EF%BC%88LeetCodeHot100%EF%BC%89121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%80%94%E2%80%94best-time-to-buy-and-sell-stock/" title="（LeetCodeHot100）121. 买卖股票的最佳时机——best-time-to-buy-and-sell-stock"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=bc458b39-4a77-259d-a304-a5de60db3fda" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-12</div><div class="title">（LeetCodeHot100）121. 买卖股票的最佳时机——best-time-to-buy-and-sell-stock</div></div></a></div><div><a href="/2025/11/12/%EF%BC%88LeetCodeHot100%EF%BC%89136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%80%94%E2%80%94single-number/" title="（LeetCodeHot100）136. 只出现一次的数字——single-number"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=c3c6c8f1-c121-119a-7821-a6245fb70ea8" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-12</div><div class="title">（LeetCodeHot100）136. 只出现一次的数字——single-number</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510132339315.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510132339315.jpg" style="width: 100%; height: auto; display: block; border-radius: 8px;"></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、反射概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是反射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">2. 反射机制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E5%B0%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">3. 反射优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4. 类加载概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%84%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text">5. 类加载各阶段完成的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 加载阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 连接阶段——验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%E2%80%94%E2%80%94%E5%87%86%E5%A4%87"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 连接阶段——准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 连接阶段——解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 初始化阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Class-%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">二、Class 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%EF%BC%9AJVM-%E5%8A%A0%E8%BD%BD%E7%B1%BB%E6%97%B6%EF%BC%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">2.0.1.</span> <span class="toc-text">具体创建时机：JVM 加载类时（类加载阶段）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1. 动态加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.</span> <span class="toc-text">2. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">三、访问字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">1. 获取字段值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">2. 设置字段值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">3. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、调用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">1. 调用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">2. 调用静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E9%9D%9E-public%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">3. 调用非 public方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">4. 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">5. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、调用构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%8E%B7%E5%8F%96%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六、获取继承方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84Class"><span class="toc-number">6.1.</span> <span class="toc-text">1. 获取父类的Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96interface"><span class="toc-number">6.2.</span> <span class="toc-text">2. 获取interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">6.3.</span> <span class="toc-text">3. 继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">4. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">七、动态代理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8978.%20%E5%AD%90%E9%9B%86%E2%80%94%E2%80%94subsets/" title="（LeetCodeHot100）78. 子集——subsets"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=21271dad-a56a-3206-d7d2-1c4a61b9d4b7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（LeetCodeHot100）78. 子集——subsets"/></a><div class="content"><a class="title" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8978.%20%E5%AD%90%E9%9B%86%E2%80%94%E2%80%94subsets/" title="（LeetCodeHot100）78. 子集——subsets">（LeetCodeHot100）78. 子集——subsets</a><time datetime="2025-12-14T07:28:00.000Z" title="发表于 2025-12-14 15:28:00">2025-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8975.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%E2%80%94%E2%80%94sort-colors/" title="（LeetCodeHot100）75. 颜色分类——sort-colors"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=94fab735-ef99-4c9a-74df-e8ea4418c241" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（LeetCodeHot100）75. 颜色分类——sort-colors"/></a><div class="content"><a class="title" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8975.%20%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%E2%80%94%E2%80%94sort-colors/" title="（LeetCodeHot100）75. 颜色分类——sort-colors">（LeetCodeHot100）75. 颜色分类——sort-colors</a><time datetime="2025-12-14T06:52:00.000Z" title="发表于 2025-12-14 14:52:00">2025-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8972.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E2%80%94%E2%80%94edit-distance/" title="（LeetCodeHot100）72. 编辑距离——edit-distance"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=b7a91123-13a6-8acd-6f43-cf27814fdd17" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（LeetCodeHot100）72. 编辑距离——edit-distance"/></a><div class="content"><a class="title" href="/2025/12/14/%EF%BC%88LeetCodeHot100%EF%BC%8972.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E2%80%94%E2%80%94edit-distance/" title="（LeetCodeHot100）72. 编辑距离——edit-distance">（LeetCodeHot100）72. 编辑距离——edit-distance</a><time datetime="2025-12-14T04:05:00.000Z" title="发表于 2025-12-14 12:05:00">2025-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="java中的反射机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=52fea558-31d3-279e-541b-87c730ca6dde" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java中的反射机制"/></a><div class="content"><a class="title" href="/2025/12/13/%EF%BC%88java%EF%BC%89java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="java中的反射机制">java中的反射机制</a><time datetime="2025-12-13T15:02:00.000Z" title="发表于 2025-12-13 23:02:00">2025-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/13/%EF%BC%88LeetCodeHot100%EF%BC%8964.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E2%80%94%E2%80%94minimum-path-sum/" title="（LeetCodeHot100）64. 最小路径和——minimum-path-sum"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://zhangzhanglaila.oss-cn-beijing.aliyuncs.com/202510152221253.JPG?_r_=65ac5f6e-4835-5655-bbf8-cd5fedb73320" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（LeetCodeHot100）64. 最小路径和——minimum-path-sum"/></a><div class="content"><a class="title" href="/2025/12/13/%EF%BC%88LeetCodeHot100%EF%BC%8964.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E2%80%94%E2%80%94minimum-path-sum/" title="（LeetCodeHot100）64. 最小路径和——minimum-path-sum">（LeetCodeHot100）64. 最小路径和——minimum-path-sum</a><time datetime="2025-12-13T12:40:00.000Z" title="发表于 2025-12-13 20:40:00">2025-12-13</time></div></div></div></div><div class="card-widget card-map"><div class="card-content"><div class="item-headline"><i class="fa fa-globe-asia" aria-hidden="true"></i><span>访客地图</span></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=NrKXiqwOJfxSliMr6I1UmdORp6XDbtPAqaHcIkDWbOc"></script></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="zhangzhang" target="_blank">zhangzhang</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">165</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">55</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BFS/" style="font-size: 0.88rem;">BFS<sup>4</sup></a><a href="/tags/Boyer-Moore/" style="font-size: 0.88rem;">Boyer-Moore<sup>1</sup></a><a href="/tags/DFS/" style="font-size: 0.88rem;">DFS<sup>10</sup></a><a href="/tags/DP/" style="font-size: 0.88rem;">DP<sup>7</sup></a><a href="/tags/Hash/" style="font-size: 0.88rem;">Hash<sup>10</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>47</sup></a><a href="/tags/Kadane-%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">Kadane 算法<sup>1</sup></a><a href="/tags/LeetCode/" style="font-size: 0.88rem;">LeetCode<sup>44</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem;">MySQL<sup>1</sup></a><a href="/tags/PTA/" style="font-size: 0.88rem;">PTA<sup>92</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c<sup>28</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>74</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/vim/" style="font-size: 0.88rem;">vim<sup>1</sup></a><a href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" style="font-size: 0.88rem;">三指针<sup>5</sup></a><a href="/tags/%E4%B8%B2/" style="font-size: 0.88rem;">串<sup>2</sup></a><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 0.88rem;">二叉树<sup>6</sup></a><a href="/tags/%E4%BD%9C%E4%B8%9A/" style="font-size: 0.88rem;">作业<sup>73</sup></a><a href="/tags/%E5%85%B1%E4%BA%AB%E6%A0%88/" style="font-size: 0.88rem;">共享栈<sup>1</sup></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 0.88rem;">双指针<sup>20</sup></a><a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 0.88rem;">回溯<sup>5</sup></a><a href="/tags/%E5%9B%BE/" style="font-size: 0.88rem;">图<sup>8</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/" style="font-size: 0.88rem;">图床搭建<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>5</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>9</sup></a><a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 0.88rem;">快慢指针<sup>6</sup></a><a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">插件<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>98</sup></a><a href="/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" style="font-size: 0.88rem;">栈和队列<sup>22</sup></a><a href="/tags/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 0.88rem;">树和二叉树<sup>13</sup></a><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 0.88rem;">生活<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>3</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>144</sup></a><a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 0.88rem;">线性表<sup>1</sup></a><a href="/tags/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/" style="font-size: 0.88rem;">缓存问题<sup>1</sup></a><a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 0.88rem;">贪心<sup>2</sup></a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 0.88rem;">链表<sup>34</sup></a><a href="/tags/%E9%98%BF%E9%87%8C%E4%BA%91/" style="font-size: 0.88rem;">阿里云<sup>1</sup></a><a href="/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/" style="font-size: 0.88rem;">顺序表<sup>19</sup></a><a href="/tags/%E9%A9%BE%E7%85%A7/" style="font-size: 0.88rem;">驾照<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 zhangzhang 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>